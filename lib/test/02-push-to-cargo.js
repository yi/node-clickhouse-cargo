// Generated by CoffeeScript 2.5.1
(function() {
  var NUM_OF_LINE, QUERY, STATEMENT_CREATE_TABLE, STATEMENT_DROP_TABLE, STATEMENT_INSERT, TABLE_NAME, assert, createCargo, fs, isInited;

  ({createCargo, isInited} = require("../"));

  assert = require("assert");

  fs = require("fs");

  TABLE_NAME = "cargo_test.unittest02";

  QUERY = `INSERT INTO ${TABLE_NAME} `;

  STATEMENT_INSERT = `INSERT INTO ${TABLE_NAME}`;

  STATEMENT_DROP_TABLE = `DROP TABLE ${TABLE_NAME}`;

  STATEMENT_CREATE_TABLE = `CREATE TABLE IF NOT EXISTS ${TABLE_NAME}
(
  \`time\` DateTime ,
  \`step\`  UInt32,
  \`pos_id\` String DEFAULT ''
)
ENGINE = Memory()`;

  STATEMENT_CREATE_TABLE = STATEMENT_CREATE_TABLE.replace(/\n|\r/g, ' ');

  //NUM_OF_LINE = 80
  NUM_OF_LINE = 100; // NOTE: bulk flushs every 100 lines

  describe("push log to cargo", function() {
    var theBulk, theCargo, theFilepath;
    this.timeout(5000);
    theCargo = null;
    theBulk = null;
    theFilepath = null;
    before(function(done) {
      debuglog("[before]");
      theCargo = createCargo(QUERY, 999000);
      theBulk = theCargo.curBulk;
      theFilepath = theBulk.pathToFile;
      getClickHouseClient().query(STATEMENT_CREATE_TABLE, done);
    });
    after(function(done) {
      debuglog("[after] query:", STATEMENT_DROP_TABLE);
      getClickHouseClient().query(STATEMENT_DROP_TABLE, function(err) {
        done(err);
      });
    });
    it("push to cargo", function(done) {
      var i, j, ref;
      for (i = j = 0, ref = NUM_OF_LINE; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        theCargo.push(new Date(), i, "string");
      }
      assert(fs.existsSync(theFilepath), `log file not exist on ${theFilepath}`);
      setTimeout(done, 2000); // wait file stream flush
    });
    return it("exam content written on hd file", function(done) {
      var contentInHD, contentInHDArr, i, j, len, line;
      contentInHD = fs.readFileSync(theFilepath, 'utf8');
      contentInHDArr = contentInHD.split(/\r|\n|\r\n/);
      console.log("[exam hd content] contentInHDArr:", contentInHDArr.length);
      assert(contentInHDArr.length === NUM_OF_LINE, "unmatching output length");
      for (i = j = 0, len = contentInHDArr.length; j < len; i = ++j) {
        line = contentInHDArr[i];
        line = JSON.parse(line);
        //console.log line
        assert(line[1] === i, "unmatching field 1 ");
        assert(line[2] === "string", "unmatching field 2 ");
      }
      done();
    });
  });

}).call(this);
