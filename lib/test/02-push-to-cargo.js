// Generated by CoffeeScript 2.5.1
(function() {
  var INIT_OPTION, NUM_OF_LINE, QUERY, STATEMENT_CREATE_TABLE, STATEMENT_DROP_TABLE, STATEMENT_INSERT, TABLE_NAME, _, assert, createCargo, debuglog, fs, getClickHouseClient, isInited;

  ({createCargo, isInited} = require("../"));

  debuglog = require("debug")("chcargo:test:02");

  ({createCargo, isInited, getClickHouseClient} = require("../"));

  assert = require("assert");

  fs = require("fs");

  _ = require("lodash");

  TABLE_NAME = "cargo_test.unittest02";

  QUERY = `INSERT INTO ${TABLE_NAME} `;

  STATEMENT_INSERT = `INSERT INTO ${TABLE_NAME}`;

  STATEMENT_DROP_TABLE = `DROP TABLE IF EXISTS ${TABLE_NAME}`;

  STATEMENT_CREATE_TABLE = `CREATE TABLE IF NOT EXISTS ${TABLE_NAME}
(
  \`time\` DateTime ,
  \`step\`  UInt32,
  \`pos_id\` String DEFAULT ''
)
ENGINE = Memory()`;

  STATEMENT_CREATE_TABLE = STATEMENT_CREATE_TABLE.replace(/\n|\r/g, ' ');

  // refer
  INIT_OPTION = {
    host: "localhost",
    maxTime: 2000,
    maxRows: 100,
    commitInterval: 8000
  };

  //NUM_OF_LINE = 80
  NUM_OF_LINE = 429; // NOTE: bulk flushs every 100 lines

  describe("push log to cargo", function() {
    var columnValueString, theCargo;
    this.timeout(20000);
    theCargo = null;
    columnValueString = Date.now().toString(36);
    before(function(done) {
      debuglog("[before]");
      getClickHouseClient().query(STATEMENT_DROP_TABLE, function(err) {
        if (err != null) {
          throw err;
        }
        getClickHouseClient().query(STATEMENT_CREATE_TABLE, function(err) {
          if (err != null) {
            throw err;
          }
          theCargo = createCargo(QUERY);
          if (fs.existsSync(theCargo.pathToCargoFile)) { // clean up existing log
            fs.unlinkSync(theCargo.pathToCargoFile);
          }
          done();
        });
      });
    });
    //after -> process.exit(0)
    it("push to cargo", function(done) {
      var i, j, ref;
      for (i = j = 0, ref = NUM_OF_LINE; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        theCargo.push(new Date(), i, columnValueString);
      }
      setTimeout(done, 5000); // wait file stream flush
    });
    it("cargo should flush to file", function() {
      assert(fs.existsSync(theCargo.pathToCargoFile), `log file not exist on ${theCargo.pathToCargoFile}`);
    });
    return it("exam content written on hd file", function(done) {
      var contentInHD, contentInHDArr, i, j, len, line;
      contentInHD = fs.readFileSync(theCargo.pathToCargoFile, 'utf8');
      //debuglog "[exam hd content] contentInHD:", contentInHD
      contentInHDArr = _.compact(contentInHD.split(/\r|\n|\r\n/));
      //debuglog "[exam hd content] contentInHDArr:", contentInHDArr
      assert(contentInHDArr.length === NUM_OF_LINE, `unmatching output length. NUM_OF_LINE:${NUM_OF_LINE}, contentInHDArr.length:${contentInHDArr.length}`);
      for (i = j = 0, len = contentInHDArr.length; j < len; i = ++j) {
        line = contentInHDArr[i];
        line = JSON.parse(line);
        //console.log line
        assert(line[1] === i, "unmatching field 1 ");
        assert(line[2] === columnValueString, "unmatching field 2 ");
      }
      done();
    });
  });

}).call(this);
