// Generated by CoffeeScript 2.5.1
(function() {
  var CLUSTER_WORKER_ID, Cargo, CargoOptions, ClickHouse, ClickHouseClient, STATEMENT_TO_CARGO, assert, cluster, createCargo, debuglog, err, examCargos, fs, init, os, path, pathToConfig, profileConfig, profileName;

  ClickHouse = require('@apla/clickhouse');

  assert = require("assert");

  path = require("path");

  os = require("os");

  fs = require("fs");

  cluster = require('cluster');

  CLUSTER_WORKER_ID = cluster.isMaster ? "nocluster" : cluster.worker.id;

  debuglog = require("debug")(`chcargo:index@${CLUSTER_WORKER_ID}`);

  Cargo = require("./cargo");

  ClickHouseClient = null;

  STATEMENT_TO_CARGO = {};

  CargoOptions = {};

  // @param Object config:
  //                     .pathToCargoFolder
  //                     .maxTime
  //                     .maxRows
  //                     .commitInterval
  init = function(config) {
    var commitInterval, isToFlushBeforeCrash, maxRows, maxTime;
    assert(ClickHouseClient === null, "ClickHouseClient has already inited");
    assert(config && config.host, "missing host in config");
    config = Object.assign({}, config); // leave input obj unmodified
    
    // prepare disk path
    CargoOptions.pathToCargoFolder = path.resolve(process.cwd(), config.cargoPath || "cargo_files");
    delete config.cargoPath;
    // verify cargo can write to the destination folder
    fs.accessSync(CargoOptions.pathToCargoFolder, fs.constants.W_OK); //, "Cargo not able to write to folder #{CargoOptions.pathToCargoFolder}"
    fs.stat(CargoOptions.pathToCargoFolder, function(err, stats) {
      assert(err == null, `Fail to read directory stats. Due to ${err}`);
      assert(stats.isDirectory(), `Not a directory: ${CargoOptions.pathToCargoFolder}`);
    });
    maxTime = parseInt(config.maxTime);
    if (maxTime > 0) {
      CargoOptions.maxTime = maxTime;
    }
    delete config.maxTime;
    maxRows = parseInt(config.maxRows);
    if (maxRows > 0) {
      CargoOptions.maxRows = maxRows;
    }
    delete config.maxRows;
    commitInterval = parseInt(config.commitInterval);
    if (commitInterval > 0) {
      CargoOptions.commitInterval = commitInterval;
    }
    delete config.commitInterval;
    //debuglog "[init] CargoOptions:", CargoOptions
    isToFlushBeforeCrash = config.saveWhenCrash !== false;
    delete config.saveWhenCrash;
    ClickHouseClient = new ClickHouse(config);
    ClickHouseClient.ping(function(err) {
      if (err) {
        throw err;
      }
    });
    if (isToFlushBeforeCrash) {
      // flush in-memroy data when process crash
      process.on('uncaughtException', function(err) {
        var cargo, statement;
        debuglog("⚠️⚠️⚠️  [flushSyncInMemoryCargo] ⚠️⚠️⚠️  ");
        for (statement in STATEMENT_TO_CARGO) {
          cargo = STATEMENT_TO_CARGO[statement];
          cargo.flushSync();
        }
        throw err;
      });
    }
  };

  // Create a cargo instance.
  // Cargos are bind to statements. Call create multiple times with the same statement, will result in one shared cargo.
  // @param statement String, sql insert statement
  createCargo = function(statement) {
    var cargo;
    debuglog(`[createCargo] statement:${statement}`);
    assert(ClickHouseClient, "ClickHouseClient needs to be inited first");
    statement = String(statement || "").trim();
    assert(statement, "statement must not be blank");
    assert(statement.toUpperCase().startsWith("INSERT"), "statement must be an insert sql");
    cargo = STATEMENT_TO_CARGO[statement];
    if (cargo) {
      debuglog("[createCargo] reuse cargo:", cargo.toString());
      return cargo;
    }
    cargo = new Cargo(ClickHouseClient, statement, CargoOptions);
    STATEMENT_TO_CARGO[statement] = cargo;
    debuglog("[createCargo] cargo:", cargo.toString());
    return cargo;
  };

  examCargos = async function() {
    var cargo, err, statement;
    // sleep
    await new Promise((resolve) => {
      return setTimeout(resolve, 1000);
    });
//debuglog "[examCargos]"
    for (statement in STATEMENT_TO_CARGO) {
      cargo = STATEMENT_TO_CARGO[statement];
      try {
        await cargo.exam(); // one-by-one
      } catch (error) {
        err = error;
        debuglog("[examCargos] FAILED error:", err);
      }
    }
    examCargos();
  };

  //# static init
  // NOTE: with env:CLICKHOUSE_CARGO_PROFILE, try init automatically
  if (process.env.CLICKHOUSE_CARGO_PROFILE) {
    profileName = process.env.CLICKHOUSE_CARGO_PROFILE;
    if (path.extname(profileName) !== ".json") {
      profileName += ".json";
    }
    pathToConfig = path.join(os.homedir(), ".clickhouse-cargo", process.env.CLICKHOUSE_CARGO_PROFILE + ".json");
    debuglog("[static init] try auto init from CLICKHOUSE_CARGO_PROFILE");
    try {
      profileConfig = JSON.parse(fs.readFileSync(pathToConfig));
    } catch (error) {
      err = error;
      debuglog("[static init] FAILED error:", err);
    }
    init(profileConfig);
  }

  // self examination routine
  examCargos();

  module.exports = {
    init: init,
    createCargo: createCargo,
    isInited: function() {
      return !!ClickHouseClient;
    },
    getClickHouseClient: function() {
      return ClickHouseClient;
    }
  };

}).call(this);
