// Generated by CoffeeScript 2.5.1
(function() {
  var CLUSTER_WORKER_ID, Cargo, CargoOptions, REG_INVALID_SQL_TABLE_NAME_CHAR, TABLE_NAME_TO_CARGO, assert, cargoOptionToHttpOption, cluster, createCargo, debuglog, err, examCargos, fs, http, https, init, os, path, pathToConfig, profileConfig, profileName;

  assert = require("assert");

  path = require("path");

  os = require("os");

  fs = require("fs");

  http = require('http');

  https = require('https');

  cluster = require('cluster');

  ({cargoOptionToHttpOption} = require("./utils"));

  CLUSTER_WORKER_ID = cluster.isMaster ? "nocluster" : cluster.worker.id;

  debuglog = require("debug")(`chcargo:index@${CLUSTER_WORKER_ID}`);

  Cargo = require("./cargo");

  REG_INVALID_SQL_TABLE_NAME_CHAR = /[^\w\d\.\-_]/i;

  TABLE_NAME_TO_CARGO = {};

  CargoOptions = {};

  // @param Object config:
  //                     .pathToCargoFolder
  //                     .maxTime
  //                     .maxRows
  //                     .commitInterval
  init = function(config) {
    var commitInterval, isToFlushBeforeCrash, maxRows, maxTime;
    if (typeof config === "string") {
      // config could be simply a string of clickhouse server host
      config = {
        host: config
      };
    }
    assert(config && config.host, "missing host in config");
    //config = Object.assign({}, config)  # leave input obj unmodified
    CargoOptions.host = config.host;
    CargoOptions.port = parseInt(config.port) || 8123;
    CargoOptions.user = config.user || "default";
    if (typeof config.password === "string") {
      CargoOptions.password = config.password;
    }
    CargoOptions.vehicle = String(config.protocol || '').toLowerCase() === 'https:' ? https : http;
    if (config.timeout > 0 && Number.isInteger(config.timeout)) {
      CargoOptions.timeout = config.timeout;
    }
    // prepare disk path
    CargoOptions.pathToCargoFolder = path.resolve(process.cwd(), config.cargoPath || "cargo_files");
    delete config.cargoPath;
    // verify cargo can write to the destination folder
    fs.accessSync(CargoOptions.pathToCargoFolder, fs.constants.W_OK); //, "Cargo not able to write to folder #{CargoOptions.pathToCargoFolder}"
    fs.stat(CargoOptions.pathToCargoFolder, function(err, stats) {
      assert(err == null, `Fail to read directory stats. Due to ${err}`);
      assert(stats.isDirectory(), `Not a directory: ${CargoOptions.pathToCargoFolder}`);
    });
    maxTime = parseInt(config.maxTime);
    if (maxTime > 0) {
      CargoOptions.maxTime = maxTime;
    }
    delete config.maxTime;
    maxRows = parseInt(config.maxRows);
    if (maxRows > 0) {
      CargoOptions.maxRows = maxRows;
    }
    delete config.maxRows;
    commitInterval = parseInt(config.commitInterval);
    if (commitInterval > 0) {
      CargoOptions.commitInterval = commitInterval;
    }
    delete config.commitInterval;
    //debuglog "[init] CargoOptions:", CargoOptions
    isToFlushBeforeCrash = config.saveWhenCrash !== false;
    delete config.saveWhenCrash;
    // pin the given ClickHouse server
    CargoOptions.vehicle.get(cargoOptionToHttpOption(CargoOptions), (function(res) {
      return assert(res && (res.statusCode === 200), `FAILED to pin ClickHouse server. Server response unexpected status code:${res && res.statusCode}`);
    })).on('error', function(err) {
      debuglog("FAILED to pin ClickHouse server, error:", err);
      throw err;
    });
    if (isToFlushBeforeCrash) {
      // flush in-memroy data when process crash
      process.on('uncaughtException', function(err) {
        var cargo, tableName;
        debuglog("⚠️⚠️⚠️  [flushSyncInMemoryCargo] ⚠️⚠️⚠️  ");
        for (tableName in STATEMENT_TO_CARGO) {
          cargo = STATEMENT_TO_CARGO[tableName];
          cargo.flushSync();
        }
        throw err;
      });
    }
  };

  // Create a cargo instance.
  // Cargos are bind to table. Call create multiple times with the same table name, will result in one shared cargo.
  // @param tableName String, the name of ClickHouse table which data is inserted
  createCargo = function(tableName) {
    var cargo;
    debuglog(`[createCargo] tableName:${tableName}`);
    assert(CargoOptions.host && CargoOptions.vehicle, "ClickHouse-Cargo needs to be inited first");
    tableName = String(tableName || "").trim();
    assert(tableName && !REG_INVALID_SQL_TABLE_NAME_CHAR.test(tableName), `invalid tableName:${tableName}`);
    cargo = TABLE_NAME_TO_CARGO[tableName];
    if (cargo) {
      debuglog(`[createCargo] reuse cargo@${tableName}:`, cargo.toString());
      return cargo;
    }
    cargo = new Cargo(tableName, CargoOptions);
    TABLE_NAME_TO_CARGO[tableName] = cargo;
    debuglog(`[createCargo] cargo@${tableName}:`, cargo.toString());
    return cargo;
  };

  examCargos = async function() {
    var cargo, err, tableName;
    // sleep
    await new Promise((resolve) => {
      return setTimeout(resolve, 1000);
    });
    debuglog("[examCargos]");
    for (tableName in TABLE_NAME_TO_CARGO) {
      cargo = TABLE_NAME_TO_CARGO[tableName];
      try {
        await cargo.exam(); // one-by-one
      } catch (error) {
        err = error;
        debuglog("[examCargos] FAILED error:", err);
      }
    }
    await examCargos();
  };

  //# static init
  // NOTE: with env:CLICKHOUSE_CARGO_PROFILE, try init automatically
  if (process.env.CLICKHOUSE_CARGO_PROFILE) {
    profileName = process.env.CLICKHOUSE_CARGO_PROFILE;
    if (path.extname(profileName) !== ".json") {
      profileName += ".json";
    }
    pathToConfig = path.join(os.homedir(), ".clickhouse-cargo", process.env.CLICKHOUSE_CARGO_PROFILE + ".json");
    debuglog("[static init] try auto init from CLICKHOUSE_CARGO_PROFILE");
    try {
      profileConfig = JSON.parse(fs.readFileSync(pathToConfig));
    } catch (error) {
      err = error;
      debuglog("[static init] FAILED error:", err);
    }
    init(profileConfig);
  }

  // self examination routine
  setTimeout((async function() {
    return (await examCargos());
  }), 100);

  // examCargos()
  module.exports = {
    init: init,
    createCargo: createCargo,
    isInited: function() {
      return !!(CargoOptions && CargoOptions.host);
    }
  };

}).call(this);
