// Generated by CoffeeScript 2.5.1
(function() {
  var ClickHouse, NUM_OF_LINE, STATEMENT_CREATE_TABLE, STATEMENT_DROP_TABLE, STATEMENT_INSERT2, StartCountWithinProcess, TABLE_NAME, assert, clickHouseClient, cluster, columnValueString, crashProc, createCargo, crypto, debuglog, fs, getClickHouseClient, isInited, os, path, prepareBulkCachFile, proc, theCargo;

  ({createCargo, isInited} = require("../"));

  debuglog = require("debug")("chcargo:cluster-test:05");

  assert = require("assert");

  crypto = require('crypto');

  fs = require("fs");

  os = require("os");

  path = require("path");

  cluster = require('cluster');

  ClickHouse = require('@apla/clickhouse');

  TABLE_NAME = "cargo_test.unittest05";

  STATEMENT_CREATE_TABLE = `CREATE TABLE IF NOT EXISTS ${TABLE_NAME}
(
  \`time\` DateTime ,
  \`step\`  UInt32,
  \`pos_id\` String DEFAULT ''
)
ENGINE = Memory()`;

  STATEMENT_CREATE_TABLE = STATEMENT_CREATE_TABLE.replace(/\n|\r/g, ' ');

  columnValueString = Date.now().toString(36);

  STATEMENT_DROP_TABLE = `DROP TABLE IF EXISTS ${TABLE_NAME}`;

  NUM_OF_LINE = 12;

  STATEMENT_INSERT2 = `insert into ${TABLE_NAME}`;

  getClickHouseClient = function() {
    var err, pathToConfig, profileConfig, profileName;
    profileName = process.env.CLICKHOUSE_CARGO_PROFILE;
    assert(profileName, "missing process.env.CLICKHOUSE_CARGO_PROFIL");
    if (path.extname(profileName) !== ".json") {
      profileName += ".json";
    }
    pathToConfig = path.join(os.homedir(), ".clickhouse-cargo", profileName);
    debuglog(`[getClickHouseClient] try auto init from CLICKHOUSE_CARGO_PROFILE from ${pathToConfig}`);
    try {
      profileConfig = JSON.parse(fs.readFileSync(pathToConfig));
    } catch (error) {
      err = error;
      debuglog("[static init] FAILED error:", err);
    }
    return new ClickHouse(profileConfig);
  };

  prepareBulkCachFile = function(tableName, label) {
    var arr, content, i, j, ref, theFilepath;
    theFilepath = path.join(process.cwd(), "cargo_files", `cargo_${tableName}.${Date.now().toString(36)}_unittest.nocluster.uncommitted`);
    debuglog("[prepare] theFilepath:", theFilepath);
    content = "";
    for (i = j = 0, ref = NUM_OF_LINE; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      arr = [Math.round(Date.now() / 1000), i, label || "cluster-cargo"];
      content += JSON.stringify(arr) + "\n";
    }
    content = content.substr(0, content.length - 1);
    fs.writeFileSync(theFilepath, content);
  };

  if (cluster.isMaster) {
    debuglog("[isMaster]");
    clickHouseClient = getClickHouseClient();
    clickHouseClient.query(STATEMENT_DROP_TABLE, function() {
      return clickHouseClient.query(STATEMENT_CREATE_TABLE, function() {
        var proc;
        prepareBulkCachFile(TABLE_NAME, "~batchAAA");
        prepareBulkCachFile(TABLE_NAME, "~batchBBB");
        proc = function() {
          var i, j;
// spawn worker
          for (i = j = 0; j < 8; i = ++j) {
            cluster.fork();
          }
        };
        proc();
        setInterval(proc, 20000);
      });
    });
  } else {
    //statment = not(cluster.worker.id % 2) && STATEMENT_INSERT || STATEMENT_INSERT2
    debuglog(`[isWorker ${cluster.worker.id}]`);
    //theCargo = createCargo(statment)
    theCargo = createCargo(TABLE_NAME);
    StartCountWithinProcess = 0;
    proc = function() {
      var i, j, mark, ref;
      mark = `worker@${cluster.worker.id}:${StartCountWithinProcess++}`;
      debuglog("proc insert: ", mark);
      for (i = j = 0, ref = NUM_OF_LINE; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        theCargo.push(new Date(), i, mark);
      }
    };
    setInterval(proc, 2000);
    crashProc = function() {
      nonExistingFunc();
    };
    setTimeout(crashProc, 10000 + Math.random() * 60000 >>> 0);
  }

}).call(this);
