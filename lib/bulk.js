// Generated by CoffeeScript 2.5.1
(function() {
  var Bulk, FILENAME_PREFIX, NOOP, NUM_OF_LINES_TO_CORK, StaticCountWithProcess, assert, cluster, debuglog, fs, path, toSQLDateString;

  cluster = require('cluster');

  path = require("path");

  fs = require("fs");

  assert = require("assert");

  debuglog = require("debug")("chcargo:bulk");

  StaticCountWithProcess = 0;

  // cork stream write
  NUM_OF_LINES_TO_CORK = 100;

  FILENAME_PREFIX = "bulk-";

  NOOP = function() {};

  toSQLDateString = function(date) {
    //debuglog "[toSQLDateString] date:", date
    return date.getUTCFullYear() + '-' + ('00' + (date.getUTCMonth() + 1)).slice(-2) + '-' + ('00' + date.getUTCDate()).slice(-2) + ' ' + ('00' + date.getUTCHours()).slice(-2) + ':' + ('00' + date.getUTCMinutes()).slice(-2) + ':' + ('00' + date.getUTCSeconds()).slice(-2);
  };

  Bulk = class Bulk {
    //toString : -> "[Bulk #{@id}@#{@pathToFile}]"
    toString() {
      return `[Bulk ${this.id}]`;
    }

    constructor(workingPath, presetId) {
      if (presetId) {
        debuglog(`[constructor] Bulk with presetId: ${presetId}`);
        this.id = presetId;
        this.count = 1; // mark bulk has content when presetId given
      } else {
        this.id = Date.now().toString(36) + `_${++StaticCountWithProcess}`;
        if (cluster.isWorker) {
          // when launch as a worker by pm2
          this.id += `_${cluster.worker.id}`;
        }
        this.count = 0;
      }
      this.pathToFile = path.join(workingPath, FILENAME_PREFIX + this.id);
      this.outputStream = fs.createWriteStream(this.pathToFile, {
        flags: 'a'
      });
      // make sure writableStream is working
      this.outputStream.write("");
      this._committed = false;
      this._committing = false;
      return;
    }

    push(arr) {
      var i, item, j, len, line;
      if (!(Array.isArray(arr) && (arr.length > 0))) {
        debuglog(`${this} [push] empty arr`);
        return;
      }
      for (i = j = 0, len = arr.length; j < len; i = ++j) {
        item = arr[i];
        if (item instanceof Date) {
          arr[i] = toSQLDateString(item);
        }
      }
      line = JSON.stringify(arr);
      if (this.count % NUM_OF_LINES_TO_CORK === 0) {
        //debuglog "#{@} [push] line:", line

        // the primary intent of writable.cork() is to accommodate a situation in which several small chunks are written to the stream in rapid succession.
        this.outputStream.cork();
      }
      this.outputStream.write((this.count > 0 ? "\n" : "") + line, 'utf8');
      ++this.count;
      if (this.count % NUM_OF_LINES_TO_CORK === 0) {
        process.nextTick(() => {
          return this.outputStream.uncork();
        });
      }
    }

    // set the expiration of this bulk
    expire(ttl) {
      debuglog(`${this} [expire] ttl:${ttl}`);
      ttl = parseInt(ttl) || 0;
      if (ttl < 1000) {
        ttl = 1000;
      }
      this.expireAt = Date.now() + ttl;
    }

    commit(clichouseClient, statement) {
      var theOutputStream;
      if (this._committing) {
        debuglog(`${this} [commit] IGNORE is _committing`);
        return;
      }
      assert(statement, "missing insert statment");
      this._committing = true; //lock
      debuglog(`${this} [commit] go committing:`, statement);
      theOutputStream = this.outputStream;
      theOutputStream.end((err) => {
        var dbStream, readableStream;
        if (err != null) {
          debuglog(`${this} [commit] FAIL to end stream. error:`, err);
          this._committing = false; //unlock
          return;
        }
        //dbStream = clichouseClient.query statement, (err)=>
        dbStream = clichouseClient.query(statement, {
          format: 'JSONCompactEachRow'
        }, (err) => {
          if (err != null) {
            debuglog(`${this} [commit] FAIL db query. error:`, err);
            this._committing = false; //unlock
            return;
          }
          try {
            this._committing = false;
            this._committed = true;
            theOutputStream.destroy();
            readableStream.destroy();
            fs.unlink(this.pathToFile, NOOP); // remove the physical file
            debuglog(`${this} [commit] success`);
          } catch (error) {
            err = error;
            debuglog(`${this} [commit] FAILED error:`, err);
          }
        });
        readableStream = fs.createReadStream(this.pathToFile);
        readableStream.pipe(dbStream);
      });
    }

    isExpired() {
      return (parseInt(this.expireAt) || 0) <= Date.now();
    }

    isEmpty() {
      return this.count === 0;
    }

    isCommitted() {
      return this._committed === true;
    }

  };

  Bulk.FILENAME_PREFIX = FILENAME_PREFIX;

  Bulk.toSQLDateString = toSQLDateString;

  module.exports = Bulk;

}).call(this);
