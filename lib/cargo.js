// Generated by CoffeeScript 2.5.1
(function() {
  var BonjourElector, Bulk, Cargo, FOLDER_PREFIX, MAX_COMMIT_PER_EXAM_ROUTINE, NOOP, assert, cluster, crypto, debuglog, fs, os, path;

  fs = require("fs");

  os = require("os");

  path = require("path");

  crypto = require('crypto');

  cluster = require('cluster');

  assert = require("assert");

  debuglog = require("debug")("chcargo:cargo");

  Bulk = require("./bulk");

  ({BonjourElector} = require('followtheleader'));

  FOLDER_PREFIX = "cargo-";

  NOOP = function() {};

  MAX_COMMIT_PER_EXAM_ROUTINE = 1;

  Cargo = class Cargo {
    //toString : -> "[Cargo #{@id}@#{@workingPath}]"
    toString() {
      return `[Cargo ${this.id}]`;
    }

    constructor(clichouseClient, statement, bulkTTL, pathToCargoFile, skipRestoration) {
      var elector;
      this.clichouseClient = clichouseClient;
      this.statement = statement;
      this.bulkTTL = bulkTTL;
      debuglog(`[new Cargo] @statement:${this.statement}, @bulkTTL:${this.bulkTTL}`);
      //@id = Date.now().toString(36)
      this.id = crypto.createHash('md5').update(this.statement).digest("hex");
      this.count = 0;
      this.bulks = [];
      //@workingPath = fs.mkdtempSync(path.join(os.tmpdir(), FOLDER_PREFIX))
      this.workingPath = path.join(pathToCargoFile, FOLDER_PREFIX + this.id);
      if (fs.existsSync(this.workingPath)) {
        // directory already exists
        assert(fs.statSync(this.workingPath).isDirectory(), `${this.workingPath} is not a directory`);
        if (!skipRestoration) {
          if (cluster.isMaster && Object.keys(cluster.workers).length === 0) {
            debuglog("[new Cargo] single process, try restoreExistingFiles");
            this.restoreExistingFiles();
          } else {
            // HERE
            debuglog("[new Cargo] cluster worker, to elect lead");
            elector = new BonjourElector({
              name: this.id
            });
            elector.on('leader', () => {
              debuglog(`worker:${cluster.worker.id} is leader, try restoreExistingFiles`);
            });
            elector.on('error', (err) => {
              debuglog(`worker:${cluster.worker.id} ELECTION error:`, err);
            });
          }
        }
      } else {
        // create directory
        fs.mkdirSync(this.workingPath);
      }
      this.curBulk = null;
      this.moveToNextBulk();
      return;
    }

    setBulkTTL(val) {
      return this.bulkTTL = val;
    }

    restoreExistingFiles() {
      debuglog("[restoreExistingFiles] @workingPath:", this.workingPath);
      fs.readdir(this.workingPath, (err, filenamList) => {
        var existingBulkId, filename, i, len, pathToFile, stats;
        if (err != null) {
          throw err;
          return;
        }
        if (!Array.isArray(filenamList)) {
          return;
        }
        filenamList = filenamList.filter(function(item) {
          return item.startsWith(Bulk.FILENAME_PREFIX);
        });
        if (!(filenamList.length > 0)) {
          return;
        }
        debuglog(`[restoreExistingFiles] filenamList(${filenamList.length})`);
        for (i = 0, len = filenamList.length; i < len; i++) {
          filename = filenamList[i];
          pathToFile = path.join(this.workingPath, filename);
          stats = fs.statSync(pathToFile);
          if (stats.size <= 0) {
            debuglog(`[restoreExistingFiles] remove empty:${filename}`);
            fs.unlink(pathToFile, NOOP);
          } else {
            existingBulkId = filename.replace(Bulk.FILENAME_PREFIX, "");
            debuglog("[restoreExistingFiles] restore existing bulk:", existingBulkId);
            this.bulks.push(new Bulk(this.workingPath, existingBulkId));
          }
        }
      });
    }

    moveToNextBulk() {
      debuglog(`${this} [moveToNextBulk]`);
      if (this.curBulk) {
        this.bulks.push(this.curBulk);
      }
      this.curBulk = new Bulk(this.workingPath);
      this.curBulk.expire(this.bulkTTL);
    }

    // routine to exame each bulk belongs to this cargo
    exam() {
      var bulk, bulksToRemove, countIssueCommit, i, j, len, len1, pos, ref;
      //debuglog "#{@} [exam]"
      if (this.curBulk) {
        if (this.curBulk.isEmpty()) {
          // lazy: keep ttl when bulk is empty
          this.curBulk.expire(this.bulkTTL);
        } else if (this.curBulk.isExpired()) {
          this.moveToNextBulk();
        }
      }
      bulksToRemove = [];
      this.bulks.sort(function(a, b) {
        return (parseInt(a.id, 36) || 0) - (parseInt(b.id, 36) || 0);
      });
      countIssueCommit = 0;
      ref = this.bulks;
      for (i = 0, len = ref.length; i < len; i++) {
        bulk = ref[i];
        if (bulk.isCommitted()) {
          bulksToRemove.push(bulk);
        } else {
          if (countIssueCommit < MAX_COMMIT_PER_EXAM_ROUTINE) {
            bulk.commit(this.clichouseClient, this.statement);
            ++countIssueCommit;
          }
        }
      }
      debuglog(`${this} [exam], bulks:`, this.bulks.length, ", bulksToRemove:", bulksToRemove.map(function(item) {
        return item.id;
      }));
      for (j = 0, len1 = bulksToRemove.length; j < len1; j++) {
        bulk = bulksToRemove[j];
        pos = this.bulks.indexOf(bulk);
        debuglog(`${this} [exam] remove bulk: ${bulk.toString()}@${pos}`);
        if (pos >= 0) {
          this.bulks.splice(pos, 1);
        }
      }
    }

    push() {
      this.curBulk.push(Array.from(arguments));
      return ++this.count;
    }

    getRetiredBulks() {
      return this.bulks.concat();
    }

  };

  module.exports = Cargo;

}).call(this);
