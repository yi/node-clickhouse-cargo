// Generated by CoffeeScript 2.5.1
(function() {
  // when in cluster worker mode, elect a leader for each cargo to avoid race condition when restoring existing bulks
  var CLUSTER_WORKER_ID, ClientSentCount, KnownHighestWorkerId, MAX_UDP_CONFIRM, REG_MSG_VALIDATOR, RemoteClientPortByCargoId, RemoteClientToPort, SERVICE_HOST, SERVICE_PORT, SERVICE_TYPE, UDPEchoSrv, assert, cluster, debuglog, dgram, err, getLeaderId, isThisLeader, msg, procSend, udpClient;

  assert = require("assert");

  cluster = require('cluster');

  dgram = require('dgram');

  CLUSTER_WORKER_ID = cluster.isMaster ? "nocluster" : cluster.worker.id;

  debuglog = require("debug")(`chcargo:leader_election@${CLUSTER_WORKER_ID}`);

  SERVICE_TYPE = "clickhouse-cargo";

  SERVICE_PORT = 17888;

  SERVICE_HOST = '127.0.0.1';

  REG_MSG_VALIDATOR = /^\d+@\w+/;

  MAX_UDP_CONFIRM = 10;

  RemoteClientPortByCargoId = {};

  RemoteClientToPort = {};

  if (cluster.isMaster) {
    isThisLeader = function() {
      return true;
    };
    getLeaderId = function() {
      return 0;
    };
  } else {
    // when running as a cluster
    KnownHighestWorkerId = cluster.worker.id;
    // setup upd server
    UDPEchoSrv = dgram.createSocket({
      type: 'udp4'
    });
    UDPEchoSrv.on('message', function(msg, rinfo) {
      var cargoId, port, workerId;
      msg = msg.toString('utf8');
      if (!REG_MSG_VALIDATOR.test(msg)) {
        debuglog(`[UDPEchoSrv] bad msg:${msg}`);
        return;
      }
      [workerId, cargoId] = msg.toString('utf8').split("@");
      ({port} = rinfo);
      //debuglog "[UDPEchoSrv > on msg] workerId:#{workerId}, cargoId:#{cargoId}, port:#{port}"
      RemoteClientToPort[workerId] = port;
//debuglog "[UDPEchoSrv > on msg] cargoId:#{cargoId}, RemoteClientToPort:", RemoteClientToPort
// echo back
      for (workerId in RemoteClientToPort) {
        port = RemoteClientToPort[workerId];
        port = parseInt(port);
        if (port !== SERVICE_PORT) {
          UDPEchoSrv.send(msg, 0, msg.length, port, SERVICE_HOST);
        }
      }
    });
    //debuglog "[UDPEchoSrv] echo back to worker:#{workerId}@port:#{port}"
    UDPEchoSrv.on("error", function(err) {
      debuglog("[static] UDP_ERR UDPEchoSrv error:", err);
    });
    try {
      UDPEchoSrv.bind(SERVICE_PORT, SERVICE_HOST, function() {
        debuglog("[static] UDPEchoSrv bind SUCCESS");
        UDPEchoSrv.setBroadcast(true);
      });
    } catch (error) {
      err = error;
      debuglog(`[static@${cluster.worker.id}] UDPEchoSrv bind failed. error`, err);
    }
    // setup udp client
    udpClient = dgram.createSocket("udp4");
    udpClient.on("message", function(msg) {
      var remoteCargoId, remoteWorkerId;
      msg = msg.toString('utf8');
      if (!REG_MSG_VALIDATOR.test(msg)) {
        debuglog(`[udpClient] bad msg:${msg}`);
        return;
      }
      [remoteWorkerId, remoteCargoId] = msg.toString('utf8').split("@");
      //debuglog "[udpClient] on msg remoteWorkerId:#{remoteWorkerId}, remoteCargoId:#{remoteCargoId}"
      remoteWorkerId = parseInt(remoteWorkerId) || 0;
      if (remoteWorkerId > KnownHighestWorkerId) {
        debuglog(`[udpClient] acknowledage new leader: ${KnownHighestWorkerId} -> ${remoteWorkerId}`);
        KnownHighestWorkerId = remoteWorkerId;
      }
    });
    ClientSentCount = 2;
    msg = Buffer.from(`${cluster.worker.id}@cluster_leader_election`);
    procSend = function() {
      if (!(ClientSentCount >= 64)) {
        ClientSentCount *= 2;
      }
      udpClient.send(msg, 0, msg.length, SERVICE_PORT, SERVICE_HOST);
      setTimeout(procSend, ClientSentCount);
    };
    procSend();
    isThisLeader = function() {
      return KnownHighestWorkerId === cluster.worker.id;
    };
    getLeaderId = function() {
      return KnownHighestWorkerId;
    };
  }

  module.exports = {
    isThisLeader: isThisLeader,
    getLeaderId: getLeaderId
  };

}).call(this);
