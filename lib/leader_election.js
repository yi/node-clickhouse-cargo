// Generated by CoffeeScript 2.5.1
(function() {
  // when in cluster worker mode, elect a leader for each cargo to avoid race condition when restoring existing bulks
  var MAX_UDP_CONFIRM, NOOP, REG_MSG_VALIDATOR, RemoteClientPortByCargoId, SERVICE_HOST, SERVICE_PORT, SERVICE_TYPE, UDPEchoSrv, assert, cluster, debuglog, dgram, electSelfToALeader, err;

  assert = require("assert");

  cluster = require('cluster');

  dgram = require('dgram');

  debuglog = require("debug")(`chcargo:leader_election@${cluster.isMaster ? "main" : cluster.worker.id}`);

  NOOP = function() {};

  SERVICE_TYPE = "clickhouse-cargo";

  SERVICE_PORT = 17888;

  SERVICE_HOST = '127.0.0.1';

  REG_MSG_VALIDATOR = /^\d+@\w+/;

  MAX_UDP_CONFIRM = 10;

  RemoteClientPortByCargoId = {};

  if (!cluster.isMaster) {
    UDPEchoSrv = dgram.createSocket({
      type: 'udp4'
    });
    UDPEchoSrv.on('message', function(msg, rinfo) {
      var cargoId, port, portCollection, workerId;
      msg = msg.toString('utf8');
      if (!REG_MSG_VALIDATOR.test(msg)) {
        debuglog(`[UDPEchoSrv] bad msg:${msg}`);
        return;
      }
      [workerId, cargoId] = msg.toString('utf8').split("@");
      ({port} = rinfo);
      //debuglog "[UDPEchoSrv > on msg] workerId:#{workerId}, cargoId:#{cargoId}, port:#{port}"
      portCollection = RemoteClientPortByCargoId[cargoId] || {};
      portCollection[port] = true;
      RemoteClientPortByCargoId[cargoId] = portCollection;
// echo back
      for (port in portCollection) {
        port = parseInt(port);
        if (port !== SERVICE_PORT) {
          UDPEchoSrv.send(msg, 0, msg.length, port, SERVICE_HOST);
        }
      }
    });
    UDPEchoSrv.on("error", function(err) {
      debuglog("[static] UDPEchoSrv error:", err);
    });
    try {
      UDPEchoSrv.bind(SERVICE_PORT, SERVICE_HOST, function() {
        debuglog("[static] UDPEchoSrv bind SUCCESS");
        UDPEchoSrv.setBroadcast(true);
      });
    } catch (error) {
      err = error;
      debuglog(`[static@${cluster.worker.id}] UDPEchoSrv bind failed. error`, err);
    }
  }

  // communicate with other cluster worker and to elect a leader worker for the given cargoId
  electSelfToALeader = function(cargoId, callbak = NOOP) {
    var cargoLeaderId, countSend, msg, procSend, udpClient, workerId;
    if (cluster.isMaster && Object.keys(cluster.workers).length === 0) {
      debuglog("[electSelfToALeader] single process leader");
      callbak();
      return;
    }
    workerId = cluster.worker.id;
    msg = Buffer.from(String(workerId) + "@" + cargoId);
    // broadcast self for a number of times
    countSend = 0;
    cargoLeaderId = -1;
    udpClient = dgram.createSocket("udp4");
    udpClient.on("message", function(msg) {
      var remoteCargoId, remoteWorkerId;
      msg = msg.toString('utf8');
      if (!REG_MSG_VALIDATOR.test(msg)) {
        debuglog(`[udpClient] bad msg:${msg}`);
        return;
      }
      [remoteWorkerId, remoteCargoId] = msg.toString('utf8').split("@");
      //debuglog "[udpClient > on msg] workerId:#{remoteWorkerId}, cargoId:#{remoteCargoId}"
      if (remoteCargoId !== cargoId) {
        debuglog(`[udpClient] ignore non-interested remoteCargoId:${remoteCargoId} as cargoId:${cargoId}`);
        return;
      }
      remoteWorkerId = parseInt(remoteWorkerId) || 0;
      if (remoteWorkerId > cargoLeaderId) {
        cargoLeaderId = remoteWorkerId;
        debuglog(`[udpClient] acknowledage new leader:${remoteWorkerId} for ${cargoId}`);
      }
    });
    procSend = function() {
      ++countSend;
      if (countSend > MAX_UDP_CONFIRM) {
        if (cargoLeaderId === workerId) {
          debuglog(`[electSelfToALeader@${workerId}] is leader for ${cargoId}`);
          callbak();
        } else {
          debuglog(`[electSelfToALeader@${workerId}] is follower for ${cargoId}`);
        }
        udpClient.close();
      } else {
        udpClient.send(msg, 0, msg.length, SERVICE_PORT, SERVICE_HOST);
        //setTimeout(procSend, Math.random() * 1000 >>> 0)
        setTimeout(procSend, 1000);
      }
    };
    procSend();
  };

  module.exports = {
    electSelfToALeader: electSelfToALeader
  };

}).call(this);
